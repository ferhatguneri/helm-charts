

## The memory threshold under which RabbitMQ will stop reading from client network sockets, in order to avoid being killed by the OS
## ref: https://www.rabbitmq.com/alarms.html
## ref: https://www.rabbitmq.com/memory.html#threshold
##
memoryHighWatermark:
  ## @param memoryHighWatermark.enabled Enable configuring Memory high watermark on RabbitMQ
  ##
  enabled: false
  ## @param memoryHighWatermark.type Memory high watermark type. Either `absolute` or `relative`
  ##
  type: "relative"
  ## Memory high watermark value.
  ## @param memoryHighWatermark.value Memory high watermark value
  ## The default value of 0.4 stands for 40% of available RAM
  ## Note: the memory relative limit is applied to the resource.limits.memory to calculate the memory threshold
  ## You can also use an absolute value, e.g.: 256MB
  ##
  value: 0.4


## @param configuration [string] RabbitMQ Configuration file content: required cluster configuration
## Do not override unless you know what you are doing.
## To add more configuration, use `extraConfiguration` of `advancedConfiguration` instead
##
configuration: |-
  {{- if not .Values.loadDefinition.enabled -}}
  ## Username and password
  ##
  default_user = {{ .Values.auth.username }}
  default_pass = CHANGEME
  {{- end }}
  {{- if .Values.clustering.enabled }}
  ## Clustering
  ##
  cluster_formation.peer_discovery_backend  = rabbit_peer_discovery_k8s
  cluster_formation.k8s.host = kubernetes.default.svc.{{ .Values.clusterDomain }}
  cluster_formation.node_cleanup.interval = 10
  cluster_formation.node_cleanup.only_log_warning = true
  cluster_partition_handling = autoheal
  {{- end }}
  # queue master locator
  queue_master_locator = min-masters
  # enable guest user
  loopback_users.guest = false
  {{ tpl .Values.extraConfiguration . }}
  {{- if .Values.auth.tls.enabled }}
  ssl_options.verify = {{ .Values.auth.tls.sslOptionsVerify }}
  listeners.ssl.default = {{ .Values.service.tlsPort }}
  ssl_options.fail_if_no_peer_cert = {{ .Values.auth.tls.failIfNoPeerCert }}
  ssl_options.cacertfile = /opt/bitnami/rabbitmq/certs/ca_certificate.pem
  ssl_options.certfile = /opt/bitnami/rabbitmq/certs/server_certificate.pem
  ssl_options.keyfile = /opt/bitnami/rabbitmq/certs/server_key.pem
  {{- end }}
  {{- if .Values.ldap.enabled }}
  auth_backends.1 = rabbit_auth_backend_ldap
  auth_backends.2 = internal
  {{- range $index, $server := .Values.ldap.servers }}
  auth_ldap.servers.{{ add $index 1 }} = {{ $server }}
  {{- end }}
  auth_ldap.port = {{ .Values.ldap.port }}
  auth_ldap.user_dn_pattern = {{ .Values.ldap.user_dn_pattern  }}
  {{- if .Values.ldap.tls.enabled }}
  auth_ldap.use_ssl = true
  {{- end }}
  {{- end }}
  {{- if .Values.metrics.enabled }}
  ## Prometheus metrics
  ##
  prometheus.tcp.port = 9419
  {{- end }}
  {{- if .Values.memoryHighWatermark.enabled }}
  ## Memory Threshold
  ##
  total_memory_available_override_value = {{ include "rabbitmq.toBytes" .Values.resources.limits.memory }}
  vm_memory_high_watermark.{{ .Values.memoryHighWatermark.type }} = {{ .Values.memoryHighWatermark.value }}
  {{- end }}

## @param extraConfiguration [string] Configuration file content: extra configuration to be appended to RabbitMQ configuration
## Use this instead of `configuration` to add more configuration
##
  
advancedConfiguration: |-

## @param extraSecrets Optionally specify extra secrets to be created by the chart.
## This can be useful when combined with load_definitions to automatically create the secret containing the definitions to be loaded.
## Example:
## extraSecrets:
##   load-definition:
##     load_definition.json: |
##       {
##         ...
##       }
##
extraSecrets:
  rabbitmq-load-definition:
    load_definition.json: |
      {
        "vhosts": [
          {
            "limits": [],
            "metadata": {
              "description": "Default virtual host",
              "tags": []
            },
            "name": "/"
          }
        ],
        "permissions": [
          {
            "configure": ".*",
            "read": ".*",
            "user": "{{ .Values.auth.username }}",
            "vhost": "/",
            "write": ".*"
          }
        ],
        "policies": [
          {
            "name": "ha-all",
            "pattern": ".*\..*",
            "vhost": "/",
            "definition": {
              "ha-mode": "all",
              "ha-sync-mode": "automatic",
              "ha-sync-batch-size": 1
            }
          }
        ],
        "users":[
            {
                "name": "{{ .Values.auth.username }}",
                "password": "{{ .Values.auth.password }}",
                "tags": "management,policymaker,monitoring,administrator"
            }
        ]
      }


loadDefinition:
  enabled: true
  existingSecret: rabbitmq-load-definition

extraConfiguration: |-
  load_definitions = /app/load_definition.json

resources:
  ## Example:
  ## limits:
  ##    cpu: 1000m
  ##    memory: 2Gi
  limits: {}
  ## Examples:
  ## requests:
  ##    cpu: 1000m
  ##    memory: 2Gi
  requests: {}

persistence:
  enabled: true
  storageClass: ""
  selector: {}
  accessMode: ReadWriteOnce
  existingClaim: ""
  size: 1Gi
  volumes: []

ingress:
  enabled: false
  path: /
  hostname: rabbitmq.local

